{-
  Abel Kaandorp (pending)
  Laurens de Gilde (11721863)
  Laurence Saes (11422629)
  Tim Vonsee (11233001)
-}
module Lab1 where
import Data.List
import Test.QuickCheck

prime :: Integer -> Bool
prime n = n > 1 && all (\ x -> rem n x /= 0) xs
        where xs = takeWhile (\ y -> y^2 <= n) primes

primes :: [Integer]
primes = 2 : filter prime [3..] 

--------------------- Exercise 1 (1 hour) ---------------------
{-
 We chose this solution because because Laurence and Tim came up with the same solotuion. 
-}
-- The left side of the expression
wextr2l :: Int -> Int
wextr2l n = sum [ x^2 | x <- [1..n] ]

-- The right side of the expression
wextr2r :: Int -> Int
wextr2r n = (n * (n+1) * (2 * n + 1)) `div` 6

extrs1Answer1 = quickCheck (\(Positive x) -> wextr2l x == wextr2r x)

-- The left side of the expression
wextr3l :: Int -> Int
wextr3l n = sum [ x^3 | x <- [1..n] ]

-- The right side of the expression
wextr3r :: Int -> Int
wextr3r n = ((n * (n+1)) `div` 2) ^ 2

extrs1Answer2 = quickCheck (\(Positive x) -> wextr3l x == wextr3r x)

--------------------- Exercise 2 (30 minutes) ---------------------
{-
  We chose this solution because it was a clearer solution because of the devision of the left and right
  hand side of the formula.

  Q: Is the property hard to test? If you find that it is, can you given a reason why?
  A:  The property is hard to test because of large input data. 
      Whenever you want to test for exaple the number 1.000.000 you are creating a list of 2^1.000.000 elements.
  
  Q: When you perform the test for exercise 4, what are you testing actually? 
      Are you checking a mathematical fact? 
      Or are you testing whether subsequences satisfies a part of its specification? 
      Or are you testing something else still?
  A: We are testing if the number of subsets generated by the function subsequences, for an array of length n, 
    statisfies the mathematical fact that it is equal to 2^n 
    (|P(A)|= 2^n, where A is a array of length n and P is the powerset).
-}


ex2w4LeftHand :: [a] -> Int
ex2w4LeftHand ns = length (subsequences ns)

ex2w4RightHand :: [a] -> Int
ex2w4RightHand ns = 2^(length ns)

ex2w4Test :: Int -> Bool
ex2w4Test n = ex2w4LeftHand ns == ex2w4RightHand ns
                where ns = [1..n]

ex2w4 = quickCheckWith stdArgs { maxSize = 30 } (\(Positive x) -> ex2w4Test x)

--------------------- Exercise 3 (45 minutes) ---------------------
{-
 We chose this solution because 
-}

-- Credits for factorial function: http://vvv.tobiassjosten.net/haskell/factorials-in-haskell/
factorial 0 = 1
factorial n = n * factorial (n - 1)

extrs3 :: Int -> Bool
extrs3 n = factorial n == perms
           where set = [1..n]
                 perms = length (permutations set)

extrs3Answer = quickCheckWith stdArgs { maxSize = 15 } (\(Positive x) -> extrs3 x)

-- Q: 'Is the property hard to test? If you find that it is, can you give a reason why?'
-- A: Same as before. Creating two equations, one for the left and one for the right, and check if these values are the same. I took the factorial function of the web.

-- Q: 'Give your thoughts on the following issue: when you perform the test for exercise 4, what are you testing actually? Are you checking a mathematical fact? Or are you testing whether subsequences satisfies a part of its specification? Or are you testing something else still?'
-- A: I think this test is more usefull then the test before. Mainly because botht the functions that we are testing are "self made". By knowing what the output should be of the left side
-- And knowing the output of the right side, and knowing that these two SHOULD be the this test is vaidating both functions in one test. 


---------------------- Exercise 4 (30 minutes) ----------------------
{-
  Run reversePrimesMax 10000 for a list of reversal primes
  This function can be compared with a list of all reversed primes to 10000. 
-}
reversal :: Integer -> Integer
reversal = read . reverse . show

reversalPrime :: Integer -> Bool
reversalPrime n = prime (reversal n)

reversePrimes :: [Integer] -> [Integer]
reversePrimes xs = filter reversalPrime xs

reversePrimesMax n = reversePrimes (takeWhile (< n) primes)

---------------------- Exercise 5 (45 minutes) ---------------------------------
{-
  We chose this because we all agreed that this was the most elegant solution.
  Run as takeSmallestPrime 101 primes
-}
takeSmallestPrime :: Int -> [Integer] -> Integer
takeSmallestPrime y ps | prime (sumPrime) = sumPrime
                       | otherwise = takeSmallestPrime  y (tail ps)
                       where
                          sumPrime = sum (take y ps)        
-- Question: 'Do you have to test that your answer is correct? How could this be checked?'
-- Answer: In my opinion this does not have to be checked if the answer is correct.
-- What I am doing it starting from 0 to 101 and if this is not a prime I increment
-- the 0 and 101 with 1. Meaning I take the next 101 consecutive primes sum these
-- and check if this is a prime. If not I recurse again and again.
-- This is a solid way of getting the smallest prime from a range.
-- The only thing that has to be checked is if the function prime works as I think it works.


--------------------- Exercise 6 (30 minutes) ---------------------------------
{-
  We chose this solution because it is consise and elegant
-}
-- n is consecutive list length
-- plist is a list of primes
consecutivePrimeTestC :: Int -> [Integer] -> [Integer]
consecutivePrimeTestC n plist | not (prime primeNumber) = primeList
                              | otherwise = consecutivePrimeTestC n (tail plist)
                                where primeList = take n plist
                                      primeNumber = (sum (primeList)) + 1

-- Time 30 minutes
-- Test with consecutivePrimeTestC n primes where n how large the list of primes have to be
-- What is the smallest counterexample?
-- with a list of 2 it is [2,3]
-- with a list of 3 it is [3,5,7]
-- with a list of 4 it is [2,3,5,7]

-------------------- Exercise 7 (2h 30m) --------------------------
{-
  We chose this solution because it was the clearest solution, it uses quickCheck and it 
  can be dynamically changed
-}
-- Credits for digs https://stackoverflow.com/questions/3963269/split-a-number-into-its-digits-with-haskell
digs :: Integral x => x -> [x]
digs 0 = []
digs x = digs (x `div` 10) ++ [x `mod` 10]

-- Apply function f on 1,3,5,7,9... and g on 2,4,6,8....
flipMap :: (a -> a) -> (a -> a) -> [a] -> [a]
flipMap _ _ [] = []
flipMap f g l = f (head l) : flipMap g f (tail l)

-- Compress number for luhn
luhnCompress :: Int -> Int
luhnCompress z = sum (digs z)

-- Do the check
luhn :: Int -> Bool
luhn x = sum checkValues `mod` 10 == 0
          where intList = digs x
                revList = reverse intList
                checkValues = flipMap id (\x -> luhnCompress (x*2)) revList

isAmericanExpress :: Int -> Bool
isAmericanExpress x = longEnought && (startCheck1 || startCheck2) && luhn x
                      where showX = show x
                            longEnought = length showX == 15
                            startCheck1 = isPrefixOf "34" showX
                            startCheck2 = isPrefixOf "37" showX

isMaster :: Int -> Bool
isMaster x = longEnought && (startCheck1 || startCheck2) && luhn x
                      where showX = show x
                            longEnought = length showX == 16
                            startCheck1 = or (map (\n -> isPrefixOf (show n) showX) [2221..2720] )
                            startCheck2 = or (map (\n -> isPrefixOf (show n) showX) [51..55] )

isVisa :: Int -> Bool
isVisa x = longEnought && startCheck && luhn x
                      where showX = show x
                            longEnought = (length showX) `elem` [13,16,19]
                            startCheck = isPrefixOf "4" showX

-- luhn check. The last digit is the check bit. One out of 10 is a correct number
generateCreditCardNumbers :: Int -> Int -> [Int]
generateCreditCardNumbers i l | inputLength == l - 1 = map (i*10+) [0..9]
                              | inputLength >= l = generateCreditCardNumbers (i `div` 10) l
                              | inputLength < l = generdfateCreditCardNumbers (i*10) l
                                where inputLength = length (show i)

-- Test if one in each group is valid
testGroup :: (Int -> Bool) -> [[Int]] -> [Bool]
testGroup f i = map (\g -> length (filter (==True) ( map f g)) == 1 ) i

prependNumber :: Int -> Int -> Int
prependNumber i j = i * (10 ^ (length (show j))) + j

generateCardNumbers :: Int -> [Int] -> [Int] -> [[Int]]
generateCardNumbers i ccLengths startWith = concat (
                                                  map (\x ->
                                                      map ( \ccLength ->
                                                        generateCreditCardNumbers (prependNumber x i) ccLength )
                                                      ccLengths )
                                                  startWith )

-- start with 34 or 37 and the size is 15
testAmericanExpress :: Int -> Bool
testAmericanExpress i = and doTest
                        where ccLength = [15]
                              startWith = [34,37]
                              groups = generateCardNumbers i ccLength startWith
                              doTest = testGroup isAmericanExpress groups

testMasterCard :: Int -> Bool
testMasterCard i = and doTest
                      where ccLength = [16]
                            startWith = concat [[2221..2720],[51..55]]
                            groups = generateCardNumbers i ccLength startWith
                            doTest = testGroup isMaster groups

testVisa :: Int -> Bool
testVisa i = and doTest
                    where ccLength = [13,16,19]
                          startWith =[4]
                          groups = generateCardNumbers i ccLength startWith
                          doTest = testGroup isVisa groups

-- Run with quickCheckWith stdArgs { maxSize = 9999999999999 }  (\(Positive x) -> testAmericanExpress x)
-- Run with quickCheckWith stdArgs { maxSize = 99999999999999 }  (\(Positive x) -> testMasterCard x)
-- Run with quickCheckWith stdArgs { maxSize = 999999999999999999 }  (\(Positive x) -> testVisa x)

--------------------- Exercise 8 (1 hour) ------------------------------
{-
  We all colaborated on this one because it was not clear on what the best approach was. 
-}
data Boy = Matthew | Peter | Jack | Arnold | Carl deriving (Eq, Show)

boys :: [Boy]
boys = [Matthew, Peter, Jack, Arnold, Carl]
                    
accuses :: Boy -> Boy -> Bool
-- Matthew accuses
accuses Matthew x | x == Carl = False
                  | x == Matthew = False
                  | otherwise = True
-- Peter accuses
accuses Peter x | x == Matthew = True
                | x == Jack = True
                | otherwise = False
-- Jack accuses
accuses Jack x = not ( (accuses Matthew x) || (accuses Peter x) )
-- Arnold accuses
accuses Arnold x = accuses Matthew x /= accuses Peter x
-- Carl accuses
accuses Carl x = not (accuses Arnold x)

accusers :: Boy -> [Boy]
accusers x = filter (\b -> accuses b x) boys 

honest :: [Boy]
honest = [b | b <- boys, g <- guilty, accuses b g]

guilty :: [Boy]
guilty = filter (\b -> length (accusers b) == 3) boys 

------------------------- Bonus 9 & 10 (2 hours) --------------------

isPythagorean :: Int -> Int -> Int -> Bool
isPythagorean x y z = x < y && y < z && x * x + y * y == z * z

sumCombinationsTill :: Int -> [(Int,Int,Int)]
sumCombinationsTill t = [(x,y,z) | x <- [1..t], y <- [1..t], z <- [1..t], x + y + z == t]

--main :: IO ()
--main = print([(x,y,z) | (x,y,z) <- (sumCombinationsTill 1000), isPythagorean x y z ])
-- 31875000

getPrimes :: Integer -> [Integer] -> [Integer]
getPrimes _ [] = []
getPrimes x ys | prime x = x : getPrimes (head nextForPrime) nextForPrime
               | otherwise = getPrimes (head next) next
                 where nextForPrime = filter (\z -> z `mod` x /= 0 ) (tail ys)
                       next = tail ys
--main :: IO ()
--main = sum (filter (\x -> x < 2000000) primes)
-- 142913828922

------------------------- Bonus 49 (2 hours) --------------------

--Credits https://stackoverflow.com/questions/21265454/subsequences-of-length-n-from-list-performance/21288092#21288092
subsequencesOfSize :: Int -> [a] -> [[a]]
subsequencesOfSize n xs = let l = length xs
                          in if n>l then [] else subsequencesBySize xs !! (l-n)
 where
   subsequencesBySize [] = [[[]]]
   subsequencesBySize (x:xs) = let next = subsequencesBySize xs
                             in zipWith (++) ([]:next) (map (map (x:)) next ++ [[]])

-- https://stackoverflow.com/questions/16108714/haskell-removing-duplicates-from-a-list
rmdups :: (Ord a) => [a] -> [a]
rmdups = map head . group . sort


getTrippleSequences :: [[Integer]] -> [[Integer]]
getTrippleSequences [] = []
getTrippleSequences (x:xs) | length x /= 3 = next
                           | xyd == yzd = [x1,x2,x3] : next
                           | otherwise = next  
                                    where x1 = x !! 0
                                          x2 = x !! 1
                                          x3 = x !! 2
                                          xyd = abs (x1-x2)
                                          yzd = abs (x2-x3)
                                          next = getTrippleSequences xs

getPPermutations :: Integer -> [[Integer]]
getPPermutations prm | permsPrimeC >= 3 = subsequencesOfSize 3 permsPrimeList
                     | otherwise = []    
                        where perms = rmdups (permutations (show prm))
                              permsN = filter (\x -> length (show x) == 4 ) (map read perms)
                              permsPrimeList = filter prime permsN
                              permsPrimeC = length (permsPrimeList)


primePermutation :: Integer -> Integer -> [[Integer]]
primePermutation srt stp = rmdups (getTrippleSequences ( foldr (++) [] permutationPrimes ))
                             where fromList = dropWhile (<srt) primes
                                   totalPrimeRange = takeWhile (<=stp) fromList
                                   permutationPrimes = map getPPermutations totalPrimeRange 
                   
-- primePermutation 1000 9999
-- 296962999629
-- Time 2 hours
