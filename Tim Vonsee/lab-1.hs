module Lab1 where
import Data.List
import Test.QuickCheck 

prime :: Integer -> Bool
prime n = n > 1 && all (\ x -> rem n x /= 0) xs
        where xs = takeWhile (\ y -> y^2 <= n) primes

primes :: [Integer]
primes = 2 : filter prime [3..] 

-- Exercise 1

ex1w1LeftHand :: Int -> Int
ex1w1LeftHand n = sum [x^2 | x <- [0..n]]

ex1w1RightHand :: Int -> Int
ex1w1RightHand n = n*(n+1)*(2*n+1) `div` 6

ex1w2LeftHand :: Int -> Int
ex1w2LeftHand n = sum [x^3 | x <- [0..n]]

ex1w2RightHand :: Int -> Int
ex1w2RightHand n = ((n*(n+1)) `div` 2)^2


ex1w1 = quickCheck (\(Positive x) -> ex1w1LeftHand x == ex1w1RightHand x)
ex1w2 = quickCheck (\(Positive x) -> ex1w2LeftHand x == ex1w2RightHand x)

-- Exercise 2

ex2w4LeftHand :: [a] -> Int
ex2w4LeftHand ns = length (subsequences ns)

ex2w4RightHand :: [a] -> Int
ex2w4RightHand ns = 2^(length ns)

-- Note the where ns = [1..10] and not where ns = [1..n] to save time...
ex2w4Test :: Int -> Bool
ex2w4Test n | n >= 0 = ex2w4LeftHand ns == ex2w4RightHand ns
            | otherwise = True
            where ns = [1..10]


-- ex2w4 = quickCheck (\(Positive x) -> ex2w4LeftHand x == ex2w4RightHand x)

{-
  Q: Is the property hard to test? If you find that it is, can you given a reason why?
  A: No it is not hard to test. It just takes a for subsequences to generate all subsets for a "large" n.

  Q: When you perform the test for exercise 4, what are you testing actually? 
    Are you checking a mathematical fact? 
    Or are you testing whether subsequences satisfies a part of its specification? 
    Or are you testing something else still?
  A: We are testing if the number of subsets generated by the function subsequences, for an array of length n, 
    statisfies the mathematical fact that it is equal to 2^n 
    (|P(A)|= 2^n, where A is a array of length n and P is the powerset).
-}

-- Exercise 3
{-
  Redo exercise 5 of Workshop 1 by replacing sets by lists, 
  and testing the property for integer lists of the form [1..n].

  Is the property hard to test? If you find that it is, can you given a reason why?

  Again, give your thoughts on the following issue: when you perform the test 
  for exercise 5, what are you testing actually? Are you checking a mathematical fact? 
  Or are you testing whether perms satisfies a part of its specification? 
  Or are you testing something else still?
-}

factorial n | n == 0 = 1
            | otherwise = n * factorial (n - 1)

--------------- Exercise 4 ---------------
{-
  How would you test this function, by the way?
  I would test this by comparing the return list to a list of primes and see if it has the same elements.
-}

reversal :: Integer -> Integer
reversal = read . reverse . show

reversalIsPrime :: Integer -> Bool
reversalIsPrime n = prime (reversal n)

twoWayPrime :: Integer -> Bool
twoWayPrime n = (prime n) && (reversalIsPrime n)

findRPrimes :: [Integer] -> [Integer]
findRPrimes ns = filter twoWayPrime ns

findSub10000RPrimes :: [Integer] -> [Integer]
findSub10000RPrimes ns = findRPrimes (filter (<10000) ns)

  
------------------ Exercise 5 ------------------
{-
  The number 101 is a prime, and it is also the sum of five consecutive primes, namely 13+17+19+23+29
  Find the smallest prime number that is a sum of 101 consecutive primes.

  Do you have to test that your answer is correct? How could this be checked?
-}

slice begin end = take end (drop begin primes)
-- sumSlice begin end = take end (drop begin primes)



------------------ Exercise 6 ------------------









